---
layout: post
title: Избегайте вложенных циклов
---

Бывают задачи, в которых вам надо пройтись по какой-то одномерной структуре (массиву, строке), но при этом в определенных случаях вам может захотеться писать 
вложенные циклы — как правило, двигающие одну и ту же переменную.

Простейший пример: пусть вам надо в строке заменить все группы подряд идущих пробелов на один, т.е. из строки `ab   cd  e` сделать `ab cd e`. 
Вы можете попробовать написать что-нибудь следующего рода:

    i = 0
    res = ""
    while i < len(s):
        if s[i] != " ":
            res += s[i]
            i += 1
        else:
            res += " "
            while s[i] == " ":
                i += 1

Казалось бы логично: все не-пробельные символы копируем, а из пробельных копируем один, а остальные пропускаем. 
Но на самом деле такого рода код обычно получается сравнительно сложным и создает риск ошибок; в частности, в коде выше есть ошибка 
(не очень сложная, но попробуйте ее найти; ответ будет дальше по тексту).

При этом подобные же задачи нередко решаются _без_ вложенных циклов. Надо просто на каждом шаге подумать, какое _одно_ действие вам надо сделать.
В этой задаче это можно написать примерно так:

    for i in range(len(s)):
        if s[i] != " ":
            res += s[i]
        else:
            if i == 0 or s[i - 1] != " ":
                res += s[i]
                
Смысл простой: мы идем по строке, и про каждый символ думаем, надо его копировать в входную строку или нет. 
Копировать надо, если это не пробел, а также если это первый пробел в группе последовательных пробелов.

Код получается заметно проще, по крайней мере по следующим параметрам. Во-первых, внешний цикл получился `for`, 
а не `while`, и мы нигде не меняет вручную переменную `i`; это избавляет нас от риска того, что мы забудем написать `i+=1`
в какой-нибудь из веток. Во-вторых, нет риска выхода за пределы строки: как только `i` дойдет до конца строки,
цикл автоматом закончится. А в коде выше, с вложенным циклом, ошибка как раз в выходе за пределы строки во внутреннем цикле
— и это на самом деле очень типичная и характерная ошибка в таких задачах. В-третьих, за счет того, что код на каждой итерации
работает только с одним символом, становится намного проще его понимать и искать ошибки.
(В чем-то последнее соображение напоминает концепцию конечных автоматов, но здесь все-таки более общая и не столь формализованная ситуация.)
За счет того, что на каждой итерации вы делаете только один шаг, намного проще понимать, в каком порядке меняются
ваши переменные цикла, и проще понимать, что в целом происходит.

Еще один яркий пример. Пусть нам дана строка, и надо проверить, явлется ли она палиндромом, если удалить все пробелы
(например, классическое "а роза упала на лапу азора" является палиндромом в этом смысле). Самый простой, конечно, способ
— скопировать все не-пробельные символы во вторую строку, и дальше ее простым образом проверить, но давайте попробуем обойтись 
без дополнительной строки. Казалось бы, логично, запустим два указателя с двух концов строки, будем ими пропускать пробелы,
а не-пробельные символы сравнивать, что-то типа такого:

    def check(s):
        i = 0
        j = len(s)
        while i < j:
            while i < len(s) and s[i] == " ":
                i += 1
            while j >= 0 and s[j] == " ":
                j -= 1
            if s[i] != s[j]:
                return False

Но тут тоже есть ошибки. Во-первых, забыт сдвиг `i += 1` и `j -= 1` в конце цикла, во-вторых, если строка состоит из одних только пробелов,
то в `if` будет выход за пределы строки, ну и, возможно, есть какие-то еще проблемы, которые я сразу не заметил. 

(Плюс ко всему, этот код делает одно лишнее сравнение, если в середине строки есть пробелы — тогда `i` и `j` успеют поменяться местами,
но мы `s[i]` и `s[j]` будем все равно сравнивать. В этой задаче это не создаст проблем, кроме как в упомянутом выше случае строки
из одних пробелов, но в других ситуациях это может создать свои проблемы.)

Но можно написать так:

    def check(s):
        i = 0
        j = len(s)
        while i < j:
            if s[i] == " ":
                i += 1
                continue
            if s[j] == " ":
                j -= 1
                continue
            if s[i] != s[j]:
                return False
            i += 1
            j -= 1

и все становится проще. 

Вообще, эти соображения про то, чтобы каждый раз делать только один шаг, особенно часто применимы в задачах на два указателя, — но, как показывает первый пример,
не только в них.

----

*Мой курс по алгоритмическому программированию (и подготовке к олимпиадам) для школьников, студентов и всех желающих — [algoprog.ru](http://algoprog.ru)*
