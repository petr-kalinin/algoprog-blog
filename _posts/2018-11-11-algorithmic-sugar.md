---
layout: post
title: Про алгоритмический сахар, или почему я требую писать все вручную
---

На алгопроге на начальных уровнях есть ряд задач, которые лешко решаются стандартными 
функциями из стандартной библиотеки почти любого языка программирования
— например, [Максимум в массиве](https://algoprog.ru/material/p72) или 
[Перевести символ в верхний регистр](https://algoprog.ru/material/p103). 
Тем не менее, я всегда в этих задачах требую от учеников 
реализовать нужные действия вручную — в первом случае через цикл по массиву,
во втором — работой с кодами символов. Недавно я доформализовал ответ на вопрос,
почему я это требую.

Когда мы, например, говорим про массивы, есть очень небольшое количество простейших 
стандартных операций для работы с ними — это в первую очередь доступ к элементу
массива по индексу и создание нового массива; если мы говорим про динамические массивы
(а в современных языках программирования в первую очередь про них и имеет смысл говорить),
то еще получение длины массива, добавление элемента в конец массива и удаление последнего
элемента. И, пожалуй, все. 

Этих операций мало, они простые и понятные, но с их помощью с массивом можно делать что угодно.
Но вдобавок к ним, современные языки программирования обычно предоставляют ряд более
удобных операций — то же вычисление максимума в массиве, или например переворот массива,
или питоновские срезы. Эти операции кажутся удобными, и кажется зачем уметь вычислять максимум
через обход массива, если можно просто написать `max(a)`?

Но проблема в том, что какие бы удобные операции не предоставлял бы вам язык программирования,
найдется момент, когда выразить нужные вам действия через них станет сложно.
Найти максимум в массиве? Да, `max(a)`. Найти _номер_ такого элемента? Ну он, `a.index(max(a))`.
А если вам нужны _все_ такие индексы? Это уже несколько сложнее. Можно,
конечно, что-нибудь придумать с там `filter` или `map`, но уже как-то мутновато получается.
А если массив у вас [двумерный](https://algoprog.ru/material/p357)? Если вы попробуете
решить задачу с двумерным массивом с помощью стандартных функций, а не просто проходом
по массиву вручную, то скорее всего решение у вас получится уже сложнее.

В итоге вы или в принципе не сможете решить сложные задачи с помощью
«удобных» операций, или решение получится черезчур сложным и непонятным.

Вторая тут проблема в том, что далеко не каждый язык предоставляет такие удобные функции.
В некоторых языках подобных функций вообще нет (привет Free Pascal'у), или есть, но
использование их настолько неудобно и чревато ошибками, что проще написать вручную
(привет C++). Базовые же функции — доступ к элементу по индексу в первую очередь —
вам предоставляет любой язык, который вообще имеет понятие массивов.

Вот поэтому я считаю, что в первую очередь стоит учиться писать все нужные алгоритмы
только с использованием элементарных операций. Впоследствии вы узнаете все дополнительные
функции, сможете с ними писать ваши программы намного проще, но — и это очень важно —
вы будете понимать, что в любой сложной ситуации у вас всегда остается гарантированно работающее
решение — закатать рукава и написать код через простейшие операции. Вот это понимание,
что у вас всегда есть запасной вариант, что вы всегда можете сами закатать рукава и сделать
всю нужную работу вручную — это, на мой взгляд, одно из важнейших умений программиста.

----

...При этом есть немного другая аргументация, зачем надо уметь писать 
максимум вручную. Аргументация звучит так: прежде чем использовать стандартную функцию
максимума, надо понять, как она работает. На мой взгляд, такое объяснение весьма спорно,
потому что задать вопрос «как оно работает» можно про любой код вообще, и не только про код.
Вы написали код через `max`? А как оно работает? Вы написали код через цикл с 
доступом к каждому элементу массива? А как _оно_ работает? Грубо говоря, понимаете ли вы,
как это работает на ассемблерном уровне? Надо ли уметь писать на ассемблере, прежде чем
будете писать цикл на питоне? Про ассемблер, конечно, вопрос тот же — а понимаете ли вы,
как _он_ работает? Знаете ли вы, как устроен процессор, какие там логические элементы,
почему этот ассемблерный код работает именно так, как вы думаете? А как работают логические
элементы? А как работает транзистор и p-n переход? А как по транзистору распределена 
волновая функция электрона? И так далее, вопросы можно задавать до бесконечности.

Конечно, профессиональному программисту безусловно нужно иметь такие знания вглубь.
Конечно, надо понимать, что массив в памяти хранится подряд, и что адрес `i`-го элемента
массива можно легко вычислить. Безусловно, полезно иметь общее представления об ассемблере 
и том, как работает процессор. Но для начального обучения ничего этого, на мой взгляд, 
совершенно не надо. Что надо — это иметь конкретный набор инструментов, гарантированно
позволяющий решить любую задачу, которая у вас может появиться.

И, к счастью, когда мы говорим про алгоритмы, это все очень легко формализуется 
и описывается одной фразой: «язык Питон (C++, Паскаль, и почти любой другой 
современный язык программирования) — это 
[тьюринг-полный язык](https://ru.wikipedia.org/wiki/Полнота_по_Тьюрингу)»
— грубо говоря, это обозначает, что на этом языке можно реализовать вообще любой алгоритм 
(в том смысле, который в эту фразу вкладывает современная наука).
И не только весь язык питон, но и очень небольшое его подмножество.

Чтобы написать любой алгоритм, использующий массивы, вполне достаточно
указанных выше элементарных операций на массивах (да, это уже не совсем
тьюринг-полнота, но идеи схожие). С другой стороны,
если мы попробуем обходиться только высокоуровневыми операциями с массивами,
то далеко не каждый алгоритм получится реализовать, или по крайней мере
получится заметно сложнее. И это и есть то, про что я писал выше.
Смысл не в том, что «надо понимать, как это устроено», а в том,
что вот с этим минимальным набором операций вы сделаете все, что захотите.

----

Есть такое понятие — [синтаксический сахар](https://ru.wikipedia.org/wiki/Синтаксический_сахар). 
Это дополнения в синтаксис языка, служащие чисто для упрощения написания кода программы,
не привносящие никакого нового смысла в программу. Типичный пример — отрицательные индексы
массивов в питоне. Запись `a[-2]` во всех смыслах (ну не совсем, на самом деле) 
эквивалентна записи `a[len(a)-2]`
— смысл тот же, работать будет так же. Это никакая не оптимизация, никакой не новый 
способ доступа к элементам массива, это придумано чисто для того, чтобы код программы был проще.
Синтаксический сахар упрощает написание программ, но одним сахаром вы не обойдетесь,
иногда придется все-таки применять не-сарахные конструкции. Ну и сахар имеет, конечно,
ряд проблем, во многом сходных с теми, про которые я писал выше.
Поэтому, конечно, хорошо, если вы знаете и умеете использовать синтаксический сахар, 
но все-таки он вторичен и в первую очередь надо знать и уметь использовать основные конструкции.

(Правда, вот в википедии и в других местах как пример синтаксического сахара приводят
конструкцию `a[i]` в языке C — мне это кажется плохим примером, т.к. запись `a[i]` 
— это не просто арифметика указателей, а введение целой новой концепции — массива.
А то можно дойти до того, что циклы и `if`'ы объявить синтаксическим сахаром, т.к. есть `goto`.)

Вот на мой взгяд также имеет смысл говорить про алгоритмический сахар —
это стандартные функции, которые упрощают выполнение часто встречающихся операций.
Ту же функцию `max` для массива, или, возвращаясь к примерам в начале текста,
функцию `isdigit` вряд ли кто назовет синтаксическим сахаром, но и то и другой
— ярко выраженный алгоритмический сахар.

---

И да, я не везде, конечно, запрещаю использовать такой алгоритмический сахар.
Когда ученики уже освоились с базовыми операциями, я только рад, когда
они используют продвинутые функции — если такое использование, конечно, к месту.

----

*Мой курс по алгоритмическому программированию (и подготовке к олимпиадам) для школьников, студентов и всех желающих — [algoprog.ru](http://algoprog.ru)*
