---
layout: post
title: Особенности c++ и его IDE, или как не писать system("pause") и не получить TL
---

У языка программирования C++, а также у популярных IDE для этого языка, есть ряд особенностей, которые надо бы знать, чтобы эффективно писать на нем программы. В этом посте я постараюсь описать основные такие особенности; возможно, в дальнейшем буду постепенно добавлять сюда что-нибудь. Сначала опишу особенности IDE, потому что они полезны даже тем, кто только начинает писать на C++, а потом особенности самого языка, которые нужны уже чуть более продвинутым школьникам.

Особенности IDE
-------

На олимпиадах наиболее популярны две IDE по C++: это Code::blocks (полностью свободно распространяемая и кроссплатформеная) и Microsoft Visual Studo (есть бесплатный вариант, только под Windows, не путайте с Visual Studio Code!). На самом деле последнее время набирает популярность CLion, но у него нет полностью бесплатной версии, и я его (применительно к олимпиадам) не очень хорошо знаю, поэтому упоминать его не буду.

Code::blocks
-------

Это достаточно простая IDE без особых заморочек, очень напоминает простые IDE из других языков программирования, типа Wing IDE для питона и встроенной IDE для Pascal ABC. Все просто: создаете новый файл, пишите код, запускаете кнопкой с зеленой стрелочкой (точнее, кнопкой с шестеренкой и зеленой стрелочкой, потому что вам обычно надо скомпилировать, и только потом запускать код). После запуска и завершения программы code::blocks задерживает окошко программы на экране, чтобы вы смогли посмотреть, что вывела ваша программа, поэтому вам не надо писать в конце программы какой-либо код для приостановки программы (типа `system("pause")` или `getch`).

Особенностей тут две. Во-первых, когда вы сохраняете программу в первый раз, надо явно указать расширение файла `.cpp` (т.е. в диалоге сохранения файла написать не `my_best_program`, а `my_best_program.cpp`), иначе по умолчанию программа сохранится как `.c` и соответственно компилятор будет считать, что это программа на C, а не на C++.

Во-вторых, не так просто сделать, чтобы заработал дебаггер. Для этого, во-первых, надо, чтобы дебаггер был установлен на компьютере (code::blocks использует компилятор gcc и дебаггер gdb, надо, чтобы они были установлены), во-вторых, просто файлы, созданные по кнопке "new", code::blocks не будет отлаживать. Чтобы дебаггер заработал, надо в code::blocks создать "проект", и уже в "проект" добавить файл с исходным кодом (существующий или новый). Но это достаточно просто и прямолинейно.

MSVS
------

Заметно более продвинутая, профессиональная, IDE. В ней вы не можете просто так создать новый файл, в ней надо создавать "проект". И тут есть две проблемы.

Во-первых, если вы просто так создадите проект, то студия не будет задерживать окошко программы на экране после завершения программы. Если вы хотите посмотреть, что ваша программа вывела на экран, вам надо будет добавлять в конец программы какую-нибудь задержку типа `system("pause")` или `getch`. А это очень плохо, в частности, не все тестирующие системы хорошо к этому относятся (еще бы — вашей программе уже пора заканчивать работу, а она никак не завершается).

Вторая проблема — по умолчанию студия создает проект с включенными так называемыми pre-compiled headers, и в начале кода появляется строчка `#include "pch.h"`. Нам это не нужно, это только мешает, потому что код с такой строчкой не будет компилироваться в тестирующей системе, а без нее не будет компилироваться у вас локально в студии.

Обе проблемы решаются правильным созданием проекта. А именно, при создании проекта надо явно убедиться, что вы указали два параметра для проекта: во-первых, это должно быть console application (это повлияет на задержку программы, см. ниже), во-вторых, это должно быть empty project (а это повлияет на pch). 

Как это сделать, зависит от версии Visual Studio. В старых версиях в окошке создания проекта надо было выбрать пункт типа Console application, и уже далее в следующем окошке -- поставить галочку Empty project. В новой студии надо выбрать тип проекта Wizard, и там в выпадающем меню выбрать Console application и поставить галочку Empty project.

Общие особенности
-------

<p>Если вы пишите на C++, то есть ряд особенностей, которые вам полезно и даже необходимо знать.</p>
<h4>Быстрый ввод-вывод</h4>
<p>Стандартный ввод/вывод через <code>iostream</code> (т.е. с использованием <code>cin</code>/<code>cout</code>) по умолчанию работает медленно на больших данных. Если вам надо ввести, допустим, 100000 чисел, то с использованием <code>cin</code> вы наверняка получите time limit; аналогично если вам надо выводить много данных. Это связано с двумя проблемами.</p>

<p>Во-первых, медленно работает <code>endl</code> (для тех, кто понимает — вывод в <code>cout</code> буферизуется, но <code>endl</code> каждый раз сбрасывает буфер, реально выводя данные на диск, а реальный доступ к диску работает медленно). Поэтому не используйте <code>endl</code> вообще, используйте <code>'\n'</code>.</p>

<p>Во-вторых, есть еще проблема синхронизации с <code>stdio</code> (не буду сейчас подробнее писать, что это значит). Чтобы эту проблему побороть, есть три способа:</p>
<ul>
<li>Работать с файлами, а не с клавиатурой/экраном (если это будет допустимо на олимпиаде). У <code>fstream</code> таких проблем со скоростью работы нет.</li>
<li>Использовать для ввода/вывода конструкции из <code>stdio.h</code> (<code>scanf</code> и <code>printf</code>), а не из <code>iostream</code>.</li>
<li>Написать в самом начале программы две магические строчки (их надо выучить наизусть): 
<pre>
std::ios_base::sync_with_stdio(false);
std::cin.tie(nullptr);
</pre></li></ul>

<p>Лично я вам рекомендую использовать первый или последний вариант.</p>

<p>Еще раз: есть <b>две</b> проблемы: одна с <code>endl</code>, другая с синхронизацией stdio и iostream. Одна решается тем, что вы не используете <code>endl</code>, другая — вот одним из трех описанных выше способов. Вам надо решить <b>обе</b> проблемы, т.е. и не использовать <code>endl</code>, и как-то разобраться с синхронизацией. Типичная ошибка — написать в начале программы этот страшный код с <code>sync_with_stdio</code>, но выводить все равно через <code>endl</code>. Получите time limit exceeded все равно.

<h4>Установка стека в Visual Studio</h4>
<p>В популярных компиляторах C++ по умолчанию установлен очень маленький размер стека. Если в вашей программе глубокая рекурсия (например, если вы пишете поиск в глубину), то программа может упасть.</p>

<p>В GCC попросить большой размер стека из самой программы невозможно, это должно настраивать жюри при настройке компиляции. На нормальных олимпиадах жюри прописывает большой размер стека в настройки компиляции, будет ли это на нашей области — я не знаю.</p>

<p>Но в Visual Studio можно установить необходимый размер стека прямо из программы примерно следующей конструкцией (проверьте заранее!): <code>#pragma comment(linker, "/STACK:32000000")</code>, здесь число — это необходимый вам размер стека в байтах (в этом примере 32 миллиона байт, т.е. примерно 32 Мб). Размер стека можете посчитать в уме исходя из вашей программы, а можете и подобрать опытным путем — 32-64 Мб обычно достаточно. Учитывайте еще, конечно, ограничение по памяти.</p>

<p>Поэтому если жюри на олимпиаде нормально настроит стек в gcc (это должно быть видно в строках компиляции gcc в памятке участника), то сдавайте под gcc. Иначе если ваше решение под gcc не влезает в стек, то добавьте эту магическую строку и сдавайте под Visual Studio.</p>

с++11 и т.д.

----

*Мой курс по алгоритмическому программированию (и подготовке к олимпиадам) для школьников, студентов и всех желающих — [algoprog.ru](http://algoprog.ru)*
