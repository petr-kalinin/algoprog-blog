---
layout: post
title: Как отлаживать маленькие программы
---

Пусть у вас есть небольшая программа, которая... не работает. Причем не просто как-то не работает, а у вас есть конкретный тест, 
конкретный пример, на котором она не работает. (Если у вас такого примера нет, то у меня есть 
[отдельный текст](https://github.com/petr-kalinin/progtexts/releases/download/v2014.11.01/06_testing.pdf) 
про то, что делать в таком случае.) Как понять, что в программе не так, и как это исправить?

> На самом деле, на эту тему есть знаменитый текст 
> "[How to debug small programs](https://ericlippert.com/2014/03/05/how-to-debug-small-programs/)"
> и его [русский перевод](https://habrahabr.ru/post/339038/), но на мой взгяд
> рекомендации, приведенные там, — это излишнее усложнение, не нужное на самом деле в 90% действительно простых программ.

Итак, у вас есть тест, но вы не понимаете, почему программа на нем выдает не тот результат,
который нужен. Ну, во-первых, по возможности уменьшите тест. Если в вашей задаче вводится какой-то массив или т.п., 
то не надо разбираться с программой на массиве длины 10. Попробуйте найти тест длины 3-4, на котором программа тоже не будет работать.

Тут на самом деле есть три основных подхода.

# Представьте себе, что вы компьютер

Если у вас программа действительно небольшая, строк 10-20 максимум, то вы можете представить себя на месте компьютера 
и в уме выполнить программу. Возьмите листочек бумажки (или откройте "Блокнот"), выпишите на нем список переменных, 
которые есть в вашей программе, оставив у каждой переменной место, куда вы будете записывать их значения. 
Это будет оперативная память вашего компьютера. (В дальнейшем, когда вы освоитесь, бумажка вам не будет нужна,
вы будете держать все нужные значения в уме.)

Далее выполняйте программу пошагово, с самого начала (ну можете пропустить ввод данных, если вы в нем на 200% уверены). 
При каждом изменении значения каждой переменной выписывая измененное значение на бумажке.
Самое важное тут — это подробно и тщательно делать именно то, что написано в программе. Забудьте (точнее лучше задвиньте на задний план)
вашу задачу, забудьте, зачем вы писали этот код. Вы работаете за компьютер, компьютер ничего не знает про то,
какая у вас задача, он просто тупо выполняет написанный код. Полезно тщательно проговаривать каждую выполняемую операцию. 
Не забывайте, что операции — это не только присваивания, это еще и все управляющие конструкции (if'ы, циклы и т.д.); 
не забывайте, что в циклах на каждой итерации выполняются действия, относящиеся собственно к циклу
(проверка условия в while, увеличение индекса цикла в for). Все изменения переменных отражайте на бумажке,
каждый раз, когда вам нужно значение какой-то переменной, сверяйтесь с бумажкой.

При этом надо все-таки где-то глубоко в уме все-таки помнить, какую задачу вы решаете, и какой код зачем написан,
чтобы, как только реальное выполнение кода отойдет от того, что вы имели в виду, сразу это и заметить.

Пример. Задача "[переставить элементы в обратном порядке](https://algoprog.ru/material/p69)". 
Типичный код, который тут многие пишут, примерно такой:

    # a - массив, который вы считали
    for i in range(len(a)):
        t = a[i]
        a[i] = a[len(a) - i]
        a[len(a) - i] = t
        
Вы запускаете программу на тесте "1 2 3", и она падает. Хорошо, давайте представим, что мы выполняем эту программу за компьютер. 
У нас есть массив `a`, в котором записано `1 2 3` (и это записано у нас на бумажке), и переменные `i` и `t`. Поехали.

Начинается цикл `for`, переменная `i` становится равна `0` (на бумажке рядом с именем переменной `i` пишем `0`). 

Команда `t = a[i]`. Чему у нас равно `i`? Смотрим на бумажку, `i` равно `0`. Чему равно `a[i]`? Смотрим на бумажку, 
`a[i]` это `a[0]` это `1`. Это значение записывается в `t`. Записываем на бумажке рядом с `t` единицу.

Команда `a[i] = a[len(a)-i]`. Чему у нас равно `i`? Нулю. Чему равно `len(a)`? Трем. Чему равно `len(a)-i`? Трем. Чему равно `a[3]`? 
Ой, выход за пределы массива (не забываем, что элементы в массиве нумеруются с нуля).

Вот собственно мы нашли первую ошибку. Обратите внимание, что мы специально тщательно и подробно все проговаривали; 
если бы вы действовали поверхностно, то вы могли бы сразу сказать: "`a[len(a)-i]` — это последний элемент массива
(ведь я именно для этого писал этот код)". И вы не заметили бы ошибку. Именно поэтому и надо по максимуму забыть,
что обозначает тот код, а вместо этого просто четко и подробно выполнять то, что написано, постоянно сверяясь с бумажкой.

Хорошо, давайте исправим ошибку, теперь код такой:

    # a - массив, который вы считали
    for i in range(len(a)):
        t = a[i]
        a[i] = a[len(a) - i - 1]
        a[len(a) - i - 1] = t

Запускаем программу — и она выдает "1 2 3", т.е. как будто массив не изменился. Хорошо, поехали еще раз.

Начинается цикл `for`, переменная `i` становится равна `0` (на бумажке рядом с именем переменной `i` пишем `0`). 

Команда `t = a[i]`. Чему у нас равно `i`? Смотрим на бумажку, `i` равно `0`. Чему равно `a[i]`? Смотрим на бумажку, 
`a[i]` это `a[0]` это `1`. Это значение записывается в `t`. Записываем на бумажке рядом с `t` единицу.

Команда `a[i] = a[len(a)-i-1]`. Чему у нас равно `i`? Нулю. Чему равно `len(a)`? Трем. Чему равно `len(a)-i-1`? Двум. Чему равно `a[2]`? 
Трем. Это значение записывается в `a[i]`. Что такое `a[i]`? У нас `i` равно `0`, поэтому это нулевой элемент массива. 
Зачеркиваем единичку, которая записана на бумажке на нулевом месте в массиве, записываем туда 3.

Команда `a[len(a) - i - 1] = t`. Чему у нас равно `t`? Единице. Что такое `a[len(a) - i - 1]` Выражение в квадратных скобках мы 
только что считали (но надо как минимум внимательно проверить, что выражение тут написано то же, а лучше пересчитать), 
поэтому это `a[2]`. Значит, в `a[2]` записываем 1. Зачеркиваем число 3, которое раньше было написано в `a[2]`, записываем туда 1.

Продолжаем. Итерация цикла закончилась, начинается новая итерация цикла. `i` становится равно `1`.

Продолжаем все делать так же тщательно и подробно. Я не буду дальше все это расписывать, но (особенно если вы не видите ошибки
в коде выше) можете продолжить и все-таки найти ошибку.
